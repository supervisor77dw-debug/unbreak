/**
 * DesignPayload v1 - Stable Schema Definition
 * 
 * This schema represents a complete customer configuration that:
 * - Can be priced deterministically
 * - Can be stored with cart/order
 * - Can be reloaded to reproduce exact design
 * - Includes preview images for shop/cart/email
 * - Includes BOM for fulfillment
 * 
 * Version: design.v1
 * Last Updated: 2026-01-03
 */

/**
 * @typedef {Object} DesignPayloadV1
 * @property {string} version - Always "design.v1"
 * @property {string} designId - UUID generated by configurator
 * @property {string} productKey - Maps to shop product SKU family
 * @property {string} createdAt - ISO 8601 timestamp
 * @property {string} updatedAt - ISO 8601 timestamp
 * @property {string} locale - e.g. "de-DE", "en-US"
 * @property {string} currency - e.g. "EUR", "USD"
 * @property {DesignSelections} selections - User-visible selections
 * @property {BOMItem[]} bom - Bill of Materials for pricing/fulfillment
 * @property {DesignPreviews} previews - Render outputs
 * @property {Object} sceneState - Minimal state to recreate design
 * @property {DesignValidation} validation - Validation status
 * @property {UserText} [userText] - Optional user input
 */

/**
 * @typedef {Object} DesignSelections
 * @property {string} [variant] - Product variant ID
 * @property {string} [size] - Size selection
 * @property {string} [material] - Material selection
 * @property {string} [finish] - Surface finish
 * @property {Object<string, any>} [options] - Additional toggles/selections
 */

/**
 * @typedef {Object} BOMItem
 * @property {string} componentId - Unique component identifier
 * @property {string} componentName - Human-readable name
 * @property {string} [materialId] - Material type identifier
 * @property {ColorSpec} [color] - Color specification
 * @property {number} qty - Quantity (integer or decimal)
 * @property {string} unit - Unit of measure (pcs, m, cm, ml, g, etc)
 * @property {Object} [dimensions] - Optional dimensions
 * @property {string} [notes] - Additional notes
 */

/**
 * @typedef {Object} ColorSpec
 * @property {string} system - "RAL" | "HEX" | "PANTONE" | "CUSTOM"
 * @property {string} code - e.g. "RAL 9005" or "#0A0A0A"
 * @property {string} label - Human-readable color name
 */

/**
 * @typedef {Object} DesignPreviews
 * @property {string} [thumbPngBase64] - Small thumbnail (300x300) base64 or URL
 * @property {string} [shopPngBase64] - Larger image (900x1125) base64 or URL
 * @property {string} [glbUrl] - Optional 3D model URL
 * @property {Object} [snapshotAngle] - Camera angle for reproducibility
 * @property {number} [snapshotAngle.yaw] - Horizontal rotation
 * @property {number} [snapshotAngle.pitch] - Vertical rotation
 * @property {number} [snapshotAngle.zoom] - Zoom level
 */

/**
 * @typedef {Object} DesignValidation
 * @property {boolean} isValid - Overall validation status
 * @property {ValidationIssue[]} issues - List of validation issues
 */

/**
 * @typedef {Object} ValidationIssue
 * @property {string} code - Machine-readable issue code
 * @property {string} message - Human-readable message
 * @property {string} [severity] - "error" | "warning" | "info"
 */

/**
 * @typedef {Object} UserText
 * @property {string} [engraving] - Engraving text
 * @property {string} [noteToMaker] - Note to production team
 */

/**
 * Create an empty DesignPayload with defaults
 * @param {string} productKey - Product SKU family
 * @param {Object} [options] - Optional overrides
 * @returns {DesignPayloadV1}
 */
export function createEmptyDesignPayload(productKey, options = {}) {
  const now = new Date().toISOString();
  const designId = options.designId || generateUUID();
  
  return {
    version: 'design.v1',
    designId,
    productKey,
    createdAt: options.createdAt || now,
    updatedAt: now,
    locale: options.locale || 'de-DE',
    currency: options.currency || 'EUR',
    
    selections: options.selections || {},
    bom: options.bom || [],
    previews: options.previews || {},
    sceneState: options.sceneState || {},
    validation: options.validation || {
      isValid: false,
      issues: []
    },
    userText: options.userText || {}
  };
}

/**
 * Validate a DesignPayload structure
 * @param {any} payload - Payload to validate
 * @returns {{valid: boolean, errors: string[]}}
 */
export function validateDesignPayload(payload) {
  const errors = [];
  
  if (!payload || typeof payload !== 'object') {
    return { valid: false, errors: ['Payload must be an object'] };
  }
  
  // Required fields
  if (payload.version !== 'design.v1') {
    errors.push('version must be "design.v1"');
  }
  if (!payload.designId || typeof payload.designId !== 'string') {
    errors.push('designId must be a non-empty string');
  }
  if (!payload.productKey || typeof payload.productKey !== 'string') {
    errors.push('productKey must be a non-empty string');
  }
  if (!payload.createdAt || !isValidISO8601(payload.createdAt)) {
    errors.push('createdAt must be a valid ISO 8601 timestamp');
  }
  if (!payload.updatedAt || !isValidISO8601(payload.updatedAt)) {
    errors.push('updatedAt must be a valid ISO 8601 timestamp');
  }
  
  // Type checks
  if (payload.selections && typeof payload.selections !== 'object') {
    errors.push('selections must be an object');
  }
  if (!Array.isArray(payload.bom)) {
    errors.push('bom must be an array');
  }
  if (payload.previews && typeof payload.previews !== 'object') {
    errors.push('previews must be an object');
  }
  if (payload.sceneState && typeof payload.sceneState !== 'object') {
    errors.push('sceneState must be an object');
  }
  if (!payload.validation || typeof payload.validation !== 'object') {
    errors.push('validation must be an object');
  } else {
    if (typeof payload.validation.isValid !== 'boolean') {
      errors.push('validation.isValid must be a boolean');
    }
    if (!Array.isArray(payload.validation.issues)) {
      errors.push('validation.issues must be an array');
    }
  }
  
  return {
    valid: errors.length === 0,
    errors
  };
}

/**
 * Simple UUID v4 generator
 * @returns {string}
 */
function generateUUID() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
    const r = Math.random() * 16 | 0;
    const v = c === 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}

/**
 * Check if string is valid ISO 8601 timestamp
 * @param {string} str
 * @returns {boolean}
 */
function isValidISO8601(str) {
  if (typeof str !== 'string') return false;
  const date = new Date(str);
  return date.toISOString() === str;
}

/**
 * Calculate payload size in bytes
 * @param {DesignPayloadV1} payload
 * @returns {number}
 */
export function calculatePayloadSize(payload) {
  return new Blob([JSON.stringify(payload)]).size;
}

/**
 * Format payload size for display
 * @param {number} bytes
 * @returns {string}
 */
export function formatPayloadSize(bytes) {
  if (bytes < 1024) return `${bytes} B`;
  if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
  return `${(bytes / (1024 * 1024)).toFixed(2)} MB`;
}
