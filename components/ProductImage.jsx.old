/**
 * ProductImage - SINGLE SOURCE OF TRUTH f√ºr alle Produktbilder
 * 
 * DETERMINISTISCHES CROP-SYSTEM (KEINE AUTO-ZOOM-HEURISTIKEN!):
 * - Einheitliches 4:5 Hochformat √úBERALL
 * - coverScaleMin: mathematisch berechnet (Bild f√ºllt Container vollst√§ndig)
 * - scale: coverScaleMin bis 2.5x (User-definiert)
 * - Position x/y: geclampt damit Container immer gef√ºllt bleibt
 * - Identisch in: Shop Cards, Admin List, Admin Edit Preview
 * 
 * Props:
 * - src: Bild-URL
 * - alt: Alt-Text
 * - crop: { scale: number, x: number, y: number } (default: auto-berechnet via coverScale)
 * - variant: "card" | "adminList" | "admin-editor"
 * - className: Optionale CSS-Klasse
 * - onLoad, onError: Callbacks
 * - interactive: boolean (f√ºr Drag im Admin)
 * - onCropChange: (crop) => void (f√ºr Drag-Updates)
 */

import { useState, useRef, useEffect } from 'react';
import { calculateCoverScale, clampCropState, generateTransform } from '../lib/crop-utils';

export default function ProductImage({
  src,
  alt = 'Produktbild',
  crop = { scale: 1.0, x: 0, y: 0 },
  variant = 'card',
  className = '',
  onLoad,
  onError,
  interactive = false,
  onCropChange,
}) {
  const [isDragging, setIsDragging] = useState(false);
  const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
  const containerRef = useRef(null);

  // Debug on mount
  useEffect(() => {
    if (interactive) {
      console.log('‚úÖ ProductImage INTERACTIVE mounted:', { 
        variant, 
        hasCallback: !!onCropChange,
        src: src?.substring(0, 50)
      });
    }
  }, []);

  // Normalize crop values
  const scale = Math.max(1.0, Math.min(2.5, crop?.scale || 1.0));
  const x = Math.max(-200, Math.min(200, crop?.x || 0));
  const y = Math.max(-200, Math.min(200, crop?.y || 0));

  // Transform calculation
  const transform = `translate(calc(-50% + ${x}px), calc(-50% + ${y}px)) scale(${scale})`;

  // Debug logging (nur in Development)
  useEffect(() => {
    if (typeof window !== 'undefined' && window.location?.hostname === 'localhost') {
      console.log(`[ProductImage ${variant}] Render:`, {
        src: src?.substring(0, 60),
        crop: { scale, x, y },
        transform,
        interactive,
      });
    }
  }, [src, scale, x, y, variant, transform, interactive]);

  // Variant-specific sizes
  const sizeClasses = {
    card: '',
    adminList: '', // Gr√∂√üe wird vom Parent-Container bestimmt (60x75px)
    adminPreview: 'max-w-[400px]',
    'admin-editor': 'max-w-[400px]',
  };

  const radiusClasses = {
    card: 'rounded-xl',
    adminList: 'rounded-lg',
    adminPreview: 'rounded-xl',
    'admin-editor': 'rounded-xl',
  };

  // Drag handlers mit Debug
  const handleMouseDown = (e) => {
    if (!interactive || !onCropChange) {
      console.log('üö´ Drag disabled:', { 
        interactive, 
        hasCallback: !!onCropChange,
        variant,
        src: src?.substring(0, 50)
      });
      return;
    }
    e.preventDefault();
    console.log('üñ±Ô∏è Drag START:', { x, y, scale });
    setIsDragging(true);
    setDragStart({ x: e.clientX - x, y: e.clientY - y });
  };

  const handleMouseMove = (e) => {
    if (!isDragging || !onCropChange) return;
    e.preventDefault();
    const newX = Math.max(-200, Math.min(200, e.clientX - dragStart.x));
    const newY = Math.max(-200, Math.min(200, e.clientY - dragStart.y));
    console.log('üñ±Ô∏è Drag MOVE:', { newX, newY });
    onCropChange({ scale, x: newX, y: newY });
  };

  const handleMouseUp = () => {
    if (isDragging) {
      console.log('üñ±Ô∏è Drag END');
      setIsDragging(false);
    }
  };

  // Touch support
  const handleTouchStart = (e) => {
    if (!interactive || !onCropChange) return;
    e.preventDefault();
    const touch = e.touches[0];
    console.log('üëÜ Touch START:', { x, y });
    setIsDragging(true);
    setDragStart({ x: touch.clientX - x, y: touch.clientY - y });
  };

  const handleTouchMove = (e) => {
    if (!isDragging || !onCropChange) return;
    e.preventDefault();
    const touch = e.touches[0];
    const newX = Math.max(-200, Math.min(200, touch.clientX - dragStart.x));
    const newY = Math.max(-200, Math.min(200, touch.clientY - dragStart.y));
    onCropChange({ scale, x: newX, y: newY });
  };

  return (
    <div
      ref={containerRef}
      className={`product-image-container ${sizeClasses[variant]} ${radiusClasses[variant]} ${className}`}
      onMouseDown={handleMouseDown}
      onMouseMove={handleMouseMove}
      onMouseUp={handleMouseUp}
      onMouseLeave={handleMouseUp}
      onTouchStart={handleTouchStart}
      onTouchMove={handleTouchMove}
      onTouchEnd={handleMouseUp}
      style={{
        cursor: interactive ? (isDragging ? 'grabbing' : 'grab') : 'default',
      }}
    >
      <img
        src={src || '/images/placeholder-product.jpg'}
        alt={alt}
        onLoad={onLoad}
        onError={(e) => {
          e.target.src = '/images/placeholder-product.jpg';
          if (onError) onError(e);
        }}
        loading="lazy"
        draggable={false}
      />
      
      <style jsx>{`
        .product-image-container {
          position: relative;
          width: 100%;
          aspect-ratio: 4 / 5; /* HARD RULE: IMMER 4:5 */
          overflow: hidden;
          background: rgba(0, 0, 0, 0.05);
          user-select: none;
          touch-action: none; /* Wichtig f√ºr Touch-Drag */
        }

        .product-image-container img {
          position: absolute;
          left: 50%;
          top: 50%;
          min-width: 100%;
          min-height: 100%;
          width: auto;
          height: auto;
          max-width: none;
          max-height: none;
          /* KEIN object-fit: cover! Das w√ºrde mit transform doppelt skalieren */
          transform-origin: center center;
          transform: ${transform};
          display: block;
          pointer-events: none; /* Bild selbst soll Events nicht fangen */
        }

        /* Hover-Effekt nur wenn NICHT interactive */
        .product-image-container:not([style*="cursor: grab"]):hover img {
          transition: transform 0.4s ease;
          transform: ${transform} scale(1.05);
        }
      `}</style>
    </div>
  );
}
